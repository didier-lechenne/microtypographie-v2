/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TypographyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var UNICODE_CHARS = {
  NO_BREAK_THIN_SPACE: "\u202F",
  // espace fine insécable
  NO_BREAK_SPACE: "\xA0",
  // espace insécable
  ELLIPSIS: "\u2026",
  // ellipse
  NDASH: "\u2013",
  // tiret demi-cadratin
  MDASH: "\u2014",
  // tiret cadratin
  TIMES: "\xD7",
  // symbole fois
  LDQUO: '"',
  // guillemet ouvrant
  RDQUO: '"',
  // guillemet fermant
  LSQUO: "\u201C",
  // apostrophe ouvrante
  RSQUO: "\u201D",
  // apostrophe fermante
  LAQUO: "\xAB",
  // guillemet français ouvrant
  RAQUO: "\xBB",
  // guillemet français fermant
  TRADE: "\u2122",
  // trademark
  REG: "\xAE",
  // registered
  COPY: "\xA9"
  // copyright
};
var EllipsisFixer = class {
  constructor() {
    this.id = "ellipsis";
    this.name = "Points de suspension";
    this.description = "Remplace ... par \u2026";
    this.enabled = true;
    this.priority = 1;
    this.category = "punctuation";
  }
  fix(text) {
    return text.replace(/\.{3,}/g, UNICODE_CHARS.ELLIPSIS);
  }
  handleKeyEvent(event, editor) {
    if (event.key === "." && !event.ctrlKey && !event.metaKey) {
      const cursor = editor.getCursor();
      const line = editor.getLine(cursor.line);
      const beforeCursor = line.substring(0, cursor.ch);
      if (beforeCursor.endsWith("..")) {
        const newLine = line.substring(0, cursor.ch - 2) + UNICODE_CHARS.ELLIPSIS + line.substring(cursor.ch);
        editor.setLine(cursor.line, newLine);
        editor.setCursor({ line: cursor.line, ch: cursor.ch - 1 });
        return true;
      }
    }
    return false;
  }
  getExample() {
    return { before: "En fait...", after: `En fait${UNICODE_CHARS.ELLIPSIS}` };
  }
};
var DashFixer = class {
  constructor() {
    this.id = "dash";
    this.name = "Tirets typographiques";
    this.description = "Convertit -- en \u2014 et am\xE9liore les tirets entre nombres";
    this.enabled = true;
    this.priority = 2;
    this.category = "punctuation";
  }
  fix(text) {
    return text.replace(/--/g, UNICODE_CHARS.MDASH).replace(/(\d+)\s*-\s*(\d+)/g, `$1${UNICODE_CHARS.NDASH}$2`).replace(/\s*—\s*/g, ` ${UNICODE_CHARS.MDASH} `);
  }
  handleKeyEvent(event, editor) {
    if (event.key === "-" && !event.ctrlKey && !event.metaKey) {
      const cursor = editor.getCursor();
      const line = editor.getLine(cursor.line);
      const beforeCursor = line.substring(0, cursor.ch);
      if (beforeCursor.endsWith("-")) {
        const newLine = line.substring(0, cursor.ch - 1) + ` ${UNICODE_CHARS.MDASH} ` + line.substring(cursor.ch);
        editor.setLine(cursor.line, newLine);
        editor.setCursor({ line: cursor.line, ch: cursor.ch + 2 });
        return true;
      }
    }
    return false;
  }
  getExample() {
    return { before: "P\xE9riode 2020-2024 -- important", after: `P\xE9riode 2020${UNICODE_CHARS.NDASH}2024 ${UNICODE_CHARS.MDASH} important` };
  }
};
var FrenchSpacingFixer = class {
  constructor() {
    this.id = "french-spacing";
    this.name = "Espaces fran\xE7ais";
    this.description = "Ajoute des espaces ins\xE9cables selon les r\xE8gles fran\xE7aises";
    this.enabled = false;
    // Désactivé par défaut
    this.priority = 3;
    this.category = "spacing";
  }
  fix(text) {
    return text.replace(/\s*([;!?»])/g, `${UNICODE_CHARS.NO_BREAK_THIN_SPACE}$1`).replace(/\s*(:)/g, `${UNICODE_CHARS.NO_BREAK_SPACE}$1`).replace(/(«)\s*/g, `$1${UNICODE_CHARS.NO_BREAK_SPACE}`).replace(/\s+,/g, ",").replace(/,\s*/g, ", ");
  }
  handleKeyEvent(event, editor) {
    if (["!", "?", ";", ":"].includes(event.key) && !event.ctrlKey && !event.metaKey) {
      const cursor = editor.getCursor();
      const line = editor.getLine(cursor.line);
      const beforeCursor = line.substring(0, cursor.ch);
      const cleanBefore = beforeCursor.replace(/\s+$/, "");
      const spaceChar = event.key === ":" ? UNICODE_CHARS.NO_BREAK_SPACE : UNICODE_CHARS.NO_BREAK_THIN_SPACE;
      const newLine = cleanBefore + spaceChar + event.key + line.substring(cursor.ch);
      editor.setLine(cursor.line, newLine);
      editor.setCursor({ line: cursor.line, ch: cleanBefore.length + 2 });
      return true;
    }
    return false;
  }
  getExample() {
    return { before: "Bonjour ! Comment allez-vous ?", after: `Bonjour${UNICODE_CHARS.NO_BREAK_THIN_SPACE}! Comment allez-vous${UNICODE_CHARS.NO_BREAK_THIN_SPACE}?` };
  }
};
var SmartQuotesFixer = class {
  constructor() {
    this.id = "smart-quotes";
    this.name = "Guillemets intelligents";
    this.description = "Convertit les guillemets droits en guillemets typographiques";
    this.enabled = true;
    this.priority = 4;
    this.category = "quotes";
    this.locale = "en";
  }
  setLocale(locale) {
    this.locale = locale;
  }
  fix(text) {
    if (this.locale.startsWith("fr")) {
      return this.fixFrenchQuotes(text);
    } else {
      return this.fixEnglishQuotes(text);
    }
  }
  fixFrenchQuotes(text) {
    let result = text;
    let inQuote = false;
    result = result.replace(/"/g, () => {
      if (!inQuote) {
        inQuote = true;
        return `${UNICODE_CHARS.LAQUO}${UNICODE_CHARS.NO_BREAK_SPACE}`;
      } else {
        inQuote = false;
        return `${UNICODE_CHARS.NO_BREAK_SPACE}${UNICODE_CHARS.RAQUO}`;
      }
    });
    result = result.replace(/'/g, UNICODE_CHARS.RSQUO);
    return result;
  }
  fixEnglishQuotes(text) {
    let result = text;
    let inQuote = false;
    result = result.replace(/"/g, () => {
      if (!inQuote) {
        inQuote = true;
        return UNICODE_CHARS.LDQUO;
      } else {
        inQuote = false;
        return UNICODE_CHARS.RDQUO;
      }
    });
    result = result.replace(/(\w)'/g, `$1${UNICODE_CHARS.RSQUO}`);
    return result;
  }
  getExample() {
    if (this.locale.startsWith("fr")) {
      return { before: `Il a dit "Bonjour" et c'est parti.`, after: `Il a dit ${UNICODE_CHARS.LAQUO}${UNICODE_CHARS.NO_BREAK_SPACE}Bonjour${UNICODE_CHARS.NO_BREAK_SPACE}${UNICODE_CHARS.RAQUO} et c${UNICODE_CHARS.RSQUO}est parti.` };
    } else {
      return { before: `He said "Hello" and it's done.`, after: `He said ${UNICODE_CHARS.LDQUO}Hello${UNICODE_CHARS.RDQUO} and it${UNICODE_CHARS.RSQUO}s done.` };
    }
  }
};
var MathSymbolsFixer = class {
  constructor() {
    this.id = "math-symbols";
    this.name = "Symboles math\xE9matiques";
    this.description = "Convertit x entre nombres en \xD7 et am\xE9liore d'autres symboles";
    this.enabled = true;
    this.priority = 5;
    this.category = "symbols";
  }
  fix(text) {
    return text.replace(/(\d+)\s*x\s*(\d+)/gi, `$1${UNICODE_CHARS.TIMES}$2`).replace(/\(tm\)/gi, UNICODE_CHARS.TRADE).replace(/\(r\)/gi, UNICODE_CHARS.REG).replace(/\(c\)/gi, UNICODE_CHARS.COPY);
  }
  getExample() {
    return { before: "Matrice 3 x 4 (c) 2024", after: `Matrice 3${UNICODE_CHARS.TIMES}4 ${UNICODE_CHARS.COPY} 2024` };
  }
};
var NoSpaceBeforeCommaFixer = class {
  constructor() {
    this.id = "no-space-comma";
    this.name = "Virgules sans espace";
    this.description = "Supprime les espaces avant les virgules";
    this.enabled = true;
    this.priority = 6;
    this.category = "spacing";
  }
  fix(text) {
    return text.replace(/\s+,/g, ",").replace(/,\s*/g, ", ");
  }
  getExample() {
    return { before: "Pommes , poires,oranges", after: "Pommes, poires, oranges" };
  }
};
var TypographyEngine = class {
  constructor(settings) {
    this.fixers = /* @__PURE__ */ new Map();
    this.settings = settings;
    this.initializeFixers();
  }
  initializeFixers() {
    const fixers = [
      new EllipsisFixer(),
      new DashFixer(),
      new FrenchSpacingFixer(),
      new SmartQuotesFixer(),
      new MathSymbolsFixer(),
      new NoSpaceBeforeCommaFixer()
    ];
    fixers.forEach((fixer) => {
      this.fixers.set(fixer.id, fixer);
      if (fixer.id in this.settings.fixers) {
        fixer.enabled = this.settings.fixers[fixer.id];
      }
      if ("setLocale" in fixer && typeof fixer.setLocale === "function") {
        fixer.setLocale(this.settings.locale);
      }
    });
  }
  updateSettings(settings) {
    this.settings = settings;
    this.fixers.forEach((fixer) => {
      if (fixer.id in settings.fixers) {
        fixer.enabled = settings.fixers[fixer.id];
      }
      if ("setLocale" in fixer && typeof fixer.setLocale === "function") {
        fixer.setLocale(settings.locale);
      }
    });
  }
  getFixers() {
    return Array.from(this.fixers.values()).sort((a, b) => a.priority - b.priority);
  }
  processText(text) {
    return this.getEnabledFixers().reduce((result, fixer) => {
      return fixer.fix(result);
    }, text);
  }
  handleKeyEvent(event, editor) {
    if (!this.settings.enableRealTimeCorrection) return false;
    for (const fixer of this.getEnabledFixers()) {
      if (fixer.handleKeyEvent && fixer.handleKeyEvent(event, editor)) {
        return true;
      }
    }
    return false;
  }
  getEnabledFixers() {
    return this.getFixers().filter((fixer) => fixer.enabled);
  }
};
var DEFAULT_SETTINGS = {
  enableRealTimeCorrection: true,
  locale: "fr-FR",
  fixers: {
    "ellipsis": true,
    "dash": true,
    "french-spacing": true,
    // Règle principale pour le français
    "smart-quotes": true,
    "math-symbols": false,
    // Moins prioritaire pour commencer
    "no-space-comma": true
  }
};
var TypographyPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Chargement du plugin Typography Fixers");
    await this.loadSettings();
    this.engine = new TypographyEngine(this.settings);
    this.addCommands();
    this.registerDomEvent(document, "keydown", this.handleKeyDown.bind(this));
    this.addSettingTab(new TypographySettingTab(this.app, this));
  }
  onunload() {
    console.log("D\xE9chargement du plugin Typography Fixers");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.engine.updateSettings(this.settings);
  }
  addCommands() {
    this.addCommand({
      id: "fix-selection",
      name: "Corriger la s\xE9lection",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        if (selection) {
          const fixed = this.engine.processText(selection);
          editor.replaceSelection(fixed);
        } else {
          const content = editor.getValue();
          const fixed = this.engine.processText(content);
          editor.setValue(fixed);
        }
      }
    });
    this.addCommand({
      id: "fix-entire-note",
      name: "Corriger toute la note",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const fixed = this.engine.processText(content);
        editor.setValue(fixed);
      }
    });
    this.addCommand({
      id: "toggle-realtime",
      name: "Basculer correction temps r\xE9el",
      callback: async () => {
        this.settings.enableRealTimeCorrection = !this.settings.enableRealTimeCorrection;
        await this.saveSettings();
      }
    });
  }
  handleKeyDown(event) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView || activeView.getMode() !== "source") return;
    const editor = activeView.editor;
    if (this.engine.handleKeyEvent(event, editor)) {
      event.preventDefault();
    }
  }
};
var TypographySettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Param\xE8tres Typography Fixers" });
    new import_obsidian.Setting(containerEl).setName("Correction en temps r\xE9el").setDesc("Active la correction automatique pendant la frappe").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableRealTimeCorrection).onChange(async (value) => {
        this.plugin.settings.enableRealTimeCorrection = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Langue").setDesc("Langue pour les r\xE8gles typographiques").addDropdown(
      (dropdown) => dropdown.addOption("en-US", "Anglais (US)").addOption("en-GB", "Anglais (UK)").addOption("fr-FR", "Fran\xE7ais (France)").addOption("fr-CA", "Fran\xE7ais (Canada)").setValue(this.plugin.settings.locale).onChange(async (value) => {
        this.plugin.settings.locale = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "R\xE8gles de correction" });
    containerEl.createEl("p", {
      text: "Activez ou d\xE9sactivez les r\xE8gles typographiques selon vos besoins.",
      cls: "setting-item-description"
    });
    const fixersByCategory = this.plugin.engine.getFixers().reduce((acc, fixer) => {
      if (!acc[fixer.category]) acc[fixer.category] = [];
      acc[fixer.category].push(fixer);
      return acc;
    }, {});
    const categoryNames = {
      punctuation: "Ponctuation",
      spacing: "Espacement",
      symbols: "Symboles",
      quotes: "Guillemets"
    };
    Object.entries(fixersByCategory).forEach(([category, fixers]) => {
      containerEl.createEl("h4", { text: categoryNames[category] || category });
      fixers.forEach((fixer) => {
        const setting = new import_obsidian.Setting(containerEl).setName(fixer.name).setDesc(fixer.description).addToggle(
          (toggle) => toggle.setValue(fixer.enabled).onChange(async (value) => {
            this.plugin.settings.fixers[fixer.id] = value;
            await this.plugin.saveSettings();
          })
        );
        if (fixer.getExample) {
          const example = fixer.getExample();
          const exampleEl = setting.descEl.createDiv({ cls: "typography-example" });
          exampleEl.createSpan({ text: "Avant : ", cls: "typography-example-label" });
          exampleEl.createEl("code", { text: example.before });
          exampleEl.createEl("br");
          exampleEl.createSpan({ text: "Apr\xE8s : ", cls: "typography-example-label" });
          exampleEl.createEl("code", { text: example.after });
        }
      });
    });
    const style = containerEl.createEl("style");
    style.textContent = `
            .typography-example {
                margin-top: 8px;
                padding: 8px;
                background: var(--background-secondary);
                border-radius: 4px;
                font-size: 0.9em;
            }
            .typography-example-label {
                font-weight: 500;
            }
            .typography-example code {
                background: var(--background-primary);
                padding: 2px 4px;
                border-radius: 2px;
            }
        `;
  }
};
